![Open Source Society University (OSSU)](http://i.imgur.com/GjEbgIJ.png)

<h3 align="center">Open Source Society University</h3>
<p align="center">
  Path to a self-taught education in Computer Science!
</p>
<p align="center">
  <a href="https://github.com/sindresorhus/awesome">
    <img alt="Awesome" src="https://cdn.rawgit.com/sindresorhus/awesome/d7305f38d29fed78fa85652e3a63e154dd8e8829/media/badge.svg">
  </a>
  <a href="https://github.com/open-source-society/computer-science">
	<img alt="Open Source Society University - Computer Science" src="https://img.shields.io/badge/OSSU-computer--science-blue.svg">
  </a>
</p>

# Contents

- [About](#about)
- [Motivation & Preparation](#motivation--preparation)
- [Curriculum](#curriculum)
- [How to use this guide](#how-to-use-this-guide)
- [Prerequisites](#prerequisites)
- [Changelog](#changelog)
- [How to collaborate](#how-to-collaborate)
- [Community](#community)
- [Team](#team)
- [References](#references)

# About

This is a **solid path** for those of you who want to complete a **Computer Science** curriculum on your own time, at **little to no cost**, with courses from the **best universities** in the world.

In our curriculum, we give preference to MOOC (Massive Open Online Course) style courses because these courses were created with our style of learning in mind.
The curriculum then concludes with a **final project** to show off your skills to your friends and future employers.

# Motivation & Preparation

Here are two interesting links that can make all the difference in your journey.

The first one is a motivational video that shows a guy that went through the "MIT Challenge", which consists of learning the entire **4-year** MIT curriculum for Computer Science in **1 year**.

- [MIT Challenge](https://www.scotthyoung.com/blog/myprojects/mit-challenge-2/)

The second link is a MOOC that will teach you learning techniques used by experts in art, music, literature, math, science, sports, and many other disciplines.
These are **fundamental abilities** to succeed in our journey.

- [Learning How to Learn](https://www.coursera.org/learn/learning-how-to-learn)

**Are you ready to get started?**

# Curriculum

- [Intro CS](#intro-cs)
- [Core CS](#core-cs)
  - [Core programming](#core-programming)
  - [Core math](#core-math)
  - [Core systems](#core-systems)
  - [Core theory](#core-theory)
  - [Core applications](#core-applications)
- [Advanced CS](#advanced-cs)
  - [Advanced programming](#advanced-programming)
  - [Advanced math](#advanced-math)
  - [Advanced systems](#advanced-systems)
  - [Advanced theory](#advanced-theory)
  - [Advanced applications](#advanced-applications)
- [Pro CS](#pro-cs)
- [Final project](#final-project)

See also: [Prerequisites](#prerequisites)

---

## Intro CS

Use these courses to figure out if Computer Science is right for you.
Only proceed in the curriculum if they really excite you.

**Topics covered**:
cardinality;
imperative programming;
procedural programming;
C;
basic data structures and algorithms;
basic Python;
SQL;
basic HTML, CSS, JavaScript;
and more.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Effective Thinking Through Mathematics](https://www.edx.org/course/effective-thinking-through-mathematics-utaustinx-ut-9-01x-0) | 4 weeks | 2 hours/week | none
[Introduction to Computer Science - CS50](https://www.edx.org/course/introduction-computer-science-harvardx-cs50x#!) | 12 weeks | 10-20 hours/week | none

## Core CS

### Core programming
**Topics covered**: 
basic testing;
functional program composition;
object-oriented program design;
static typing;
dynamic typing;
common design patterns;
ML-family languages (via Standard ML);
Lisp-family languages (via Racket);
Ruby;
and more.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[How to Code: Systematic Program Design (XSeries)](https://www.edx.org/xseries/how-code-systematic-program-design) | 15 weeks | 5 hours/week | none
[Object Oriented Programming in Java](https://www.coursera.org/learn/object-oriented-java) | 6 weeks | 4-6 hours/week | some programming
[Programming Languages, Part A](https://www.coursera.org/learn/programming-languages) | 4 weeks | 8-16 hours/week | recommended: Java, C
[Programming Languages, Part B](https://www.coursera.org/learn/programming-languages-part-b) | 3 weeks | 8-16 hours/week | Programming Languages, Part A
[Programming Languages, Part C](https://www.coursera.org/learn/programming-languages-part-c) | 3 weeks | 8-16 hours/week | Programming Languages, Part B

**Note**: The Object-Oriented Programming in Java class is intended for students who have already taken a basic Java course, but it can still be completed by those who have only studied basic programming before in a different, Java-like language (e.g., C).
The learning curve will be steep, however, so for those who find it too difficult, looking over the material in this course is recommended:
[Introduction to Programming in Java](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-092-introduction-to-programming-in-java-january-iap-2010/index.htm).

### Core math

**Topics covered**:
mathematical proofs;
number theory;
differential calculus;
integral calculus;
sequences and series;
probability theory;
basic statistics;
O-notation;
graph theory;
linear transformations;
matrices;
vectors;
and more.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Linear Algebra - Foundations to Frontiers](https://www.edx.org/course/linear-algebra-foundations-frontiers-utaustinx-ut-5-04x#!)| 15 weeks | 8 hours/week | high school math
[Calculus One](https://www.coursera.org/learn/calculus1)| 16 weeks | 8-10 hours/week | pre-calculus
[Calculus Two: Sequences and Series](https://www.coursera.org/learn/advanced-calculus)| 7 weeks | 9-10 hours/week | Calculus One
[Mathematics for Computer Science](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-spring-2015/index.htm) | 13 weeks | 5 hours/week | Calculus Two
[Introduction to Probability - The Science of Uncertainty](https://www.edx.org/course/introduction-probability-science-mitx-6-041x-2) | 18 weeks | 12 hours/week | calculus

### Core systems

**Topics covered**:
boolean algebra;
gate logic;
memory;
machine language;
computer architecture;
assembly;
machine language;
virtual machines;
high-level languages;
compilers;
operating systems;
network protocols;
and more.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Build a Modern Computer from First Principles: From Nand to Tetris](https://www.coursera.org/learn/build-a-computer) | 6 weeks | 7-13 hours/week | none
[Build a Modern Computer from First Principles: Nand to Tetris Part II ](https://www.coursera.org/learn/nand2tetris2) | 6 weeks | 12-18 hours/week | Part I
[Introduction to Computer Networking](https://lagunita.stanford.edu/courses/Engineering/Networking-SP/SelfPaced/about)| - | 4â€“12 hours/week | algebra, probability, basic CS

**Note 1**: The 'From Nand to Tetris' course, in part I, will have you create an entire computer architecture from scratch, but is missing key elements from computer architecture such as pipelining and memory hierarchy.
A supplemental textbook is recommended for those who wish to go deeper into the hardware:
[Computer Organization and Design](https://smile.amazon.com/Computer-Organization-Design-Fifth-Architecture/dp/0124077269).

**Note 2**: Part II of the same course has you build the very lowest levels of an operating system on top of the computer architecture you built, however it does not go very deep into operating systems.
For those interested in this subject, this free supplemental textbook is strongly recommended:
[Operating Systems: Three Easy Pieces](http://pages.cs.wisc.edu/~remzi/OSTEP/).

Both of the above textbooks should be considered a requirement for anyone who intends to become a *[systems programmer](https://en.wikipedia.org/wiki/System_programming)*.

### Core theory

The Princeton Algorithms courses are highly recommended as a more practical, implementation-focused complement to the more theory-focused Stanford Algorithms courses.
Ideally, students would do both sets of courses since they complement each other nicely.
However, Part II of Princeton Algorithms is rarely available, so Stanford Algorithms is the recommended choice if you cannot do both.
Another difference is that Stanford Algorithms assignments can use any programming language;
Princeton Algorithms assignments use Java but don't require extensive Java experience.

**Topics covered**:
divide and conquer;
sorting and searching;
randomized algorithms;
graph search;
shortest paths;
data structures;
greedy algorithms;
minimum spanning trees;
dynamic programming;
NP-completeness;
and more.

#### Stanford Algorithms

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Algorithms (1/4)](https://www.coursera.org/learn/algorithms-divide-conquer) | 4 weeks | 4-8 hours/week | one programming language; proofs; probability
[Algorithms (2/4)](https://www.coursera.org/learn/algorithms-graphs-data-structures) | 4 weeks | 4-8 hours/week | previous algorithms course
[Algorithms (3/4)](https://www.coursera.org/learn/algorithms-greedy) | 4 weeks | 4-8 hours/week | previous algorithms course
[Algorithms (4/4)](https://www.coursera.org/learn/algorithms-npcomplete) | 4 weeks | 4-8 hours/week | previous algorithms course

#### Princeton Algorithms

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Algorithms, Part I](https://www.coursera.org/learn/algorithms-part1) | 6 weeks | 6-12 hours/week | some programming
[Algorithms, Part II](https://www.coursera.org/learn/algorithms-part2) | 6 weeks | 6-12 hours/week | Algorithms, Part I

### Core applications

**Topics covered**:
relational databases;
transaction processing;
data modeling;
neural networks;
supervised learning;
unsupervised learning;
OpenGL;
raytracing;
block ciphers;
authentication;
public key encryption;
and more.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Databases](https://lagunita.stanford.edu/courses/DB/2014/SelfPaced/about)| 12 weeks | 8-12 hours/week | some programming, basic CS
[Machine Learning](https://www.coursera.org/learn/machine-learning)| 11 weeks | 4-6 hours/week | linear algebra
[Computer Graphics](https://www.edx.org/course/computer-graphics-uc-san-diegox-cse167x)| 6 weeks | 12 hours/week | C++ or Java, linear algebra
[Cryptography I](https://www.coursera.org/course/crypto)| 6 weeks | 5-7 hours/week | linear algebra; probability

## Advanced CS

Unfortunately, advanced topics in computer science generally have less coverage in online courses.
(This is because seldom few make it past beginner-level courses, there is low demand.)
Therefore, some of these courses may not be available regularly.

### Advanced programming

**Topics covered**:
code coverage;
random testing;
debugging theory and practice;
GPU programming;
CUDA;
parallel computing;
object-oriented analysis and design;
UML;
large-scale software architecture and design;
and more.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Software Testing](https://www.udacity.com/course/software-testing--cs258)| 4 weeks | 6 hours/week | some programming
[Software Debugging](https://www.udacity.com/course/software-debugging--cs259)| 8 weeks | 6 hours/week | Python, object-oriented programming
[Introduction to Parallel Programming](https://www.udacity.com/course/intro-to-parallel-programming--cs344) | 12 weeks | - | C, algorithms
[Software Architecture & Design](https://www.udacity.com/course/software-architecture-design--ud821)| 8 weeks | 6 hours/week | Java programming

### Advanced math

**Topics covered**:
mathematical proofs;
real analysis;
goal-oriented programming;
and more.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Introduction to Mathematical Thinking](https://www.coursera.org/learn/mathematical-thinking) | 10 weeks | 10 hours/week | high school math
[LAFF: Programming for Correctness](https://www.edx.org/course/laff-programming-correctness-utaustinx-ut-p4c-14-01x) | 7 weeks | 6 hours/week | linear algebra

### Advanced systems

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:

### Advanced theory

**Topics covered**:
formal languages;
Turing machines;
computability;
and more.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Automata Theory](https://lagunita.stanford.edu/courses/course-v1:ComputerScience+Automata+Fall2016/about) | 8 weeks | 10 hours/week | discrete mathematics

### Advanced applications

Compilers is recommended to any student who took a strong interest in the Programming Languages courses.
Natural Language Processing is recommended to anyone who thinks they want to specialize in machine learning, artificial intelligence, etc.
Cryptography is recommended to anyone who wants to learn more about zero knowledge systems and other advanced topics in cryptography.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Compilers](https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/about)| 9 weeks | 6-8 hours/week | none
[Introduction to Natural Language Processing](https://www.coursera.org/learn/natural-language-processing)| 12 weeks | - | Python programming
[Cryptography II](https://www.coursera.org/course/crypto2)| 6 weeks | 6-8 hours/week | Cryptography I

## Pro CS

After finishing the curriculum above, you will have completed close to a full bachelor's degree in Computer Science.
You can stop here, but if you really want to make yourself valuable, the next step to completing your studies is to develop skills and knowledge in a specific domain.

Choose one or more of the following specializations:
- [Artificial Intelligence Engineer Nanodegree](https://www.udacity.com/ai) by IBM, Amazon, and Didi
- [Data Mining Specialization](https://www.coursera.org/specializations/data-mining) by the University of Illinois at Urbana-Champaign
- [Big Data Specialization](https://www.coursera.org/specializations/big-data) by the University of California at San Diego
- [Data Analyst Nanodegree](https://www.udacity.com/course/data-analyst-nanodegree--nd002) by Facebook and mongoDB
- [Applied Data Science with Python Specialization](https://www.coursera.org/specializations/data-science-python) by the University of Michigan
- [Data Science Specialization](https://www.coursera.org/specializations/jhu-data-science) by Johns Hopkins University
- [Mastering Software Development in R Specialization](https://www.coursera.org/specializations/r) by Johns Hopkins University
- [Machine Learning Engineer Nanodegree](https://www.udacity.com/course/machine-learning-engineer-nanodegree--nd009) by kaggle
- [Cybersecurity MicroMasters](https://www.edx.org/micromasters/ritx-cybersecurity) by the Rochester Institute of Technology
- [Cloud Computing Specialization](https://www.coursera.org/specializations/cloud-computing) by the University of Illinois at Urbana-Champaign
- [Internet of Things Specialization](https://www.coursera.org/specializations/internet-of-things) by the University of California at San Diego
- [Full Stack Web Development Specialization](https://www.coursera.org/specializations/full-stack) by the Hong Kong University of Science and Technology
- [Android Developer Nanodegree](https://www.udacity.com/course/android-developer-nanodegree-by-google--nd801) by Google

These aren't the only specializations you can choose. Check the following websites for more options:

### edX: [xSeries](https://www.edx.org/xseries)
### Coursera: [Specializations](https://www.coursera.org/specializations)
### Udacity: [Nanodegree](https://www.udacity.com/nanodegree)
### FutureLearn: [Collections](https://www.futurelearn.com/courses/collections)


## Final project

**OSS University** is **project-focused**.
You are encouraged to do the assignments and exams for each course, but what really matters is whether you can *use* your knowledge to solve a real world problem.

> "What does it mean?"

After you finish the curriculum, you should think about a problem that you can solve using the knowledge you've acquired.
Not only does real project work look great on a resume, the project will **validate** and **consolidate** your knowledge.

The final projects of all students will be listed in [this](PROJECTS.md) file.
**Submit your project's information in that file after you conclude it**.

Put the OSSU-CS badge in the README of your repository!
[![Open Source Society University - Computer Science](https://img.shields.io/badge/OSSU-computer--science-blue.svg)](https://github.com/open-source-society/computer-science)

- Markdown: `[![Open Source Society University - Computer Science](https://img.shields.io/badge/OSSU-computer--science-blue.svg)](https://github.com/open-source-society/computer-science)`
- HTML: `<a href="https://github.com/open-source-society/computer-science"><img alt="Open Source Society University - Computer Science" src="https://img.shields.io/badge/OSSU-computer--science-blue.svg"></a>`

### Cooperative work

You can create this project alone or with other students!
**We love cooperative work**!
Use our [channels](#community) to communicate with other fellows to combine and create new projects!

### Project Suggestions

- [Projects](https://github.com/karan/Projects): A list of practical projects that anyone can solve in any programming language.
- [app-specs](https://github.com/ericdouglas/app-specs): A curated list of applications specifications and implementations to practice new technologies, improve your portfolio and sharpen your skills.
- [FreeCodeCamp](http://www.freecodecamp.com/): Course that teaches you fullstack JavaScript development through a bunch of projects.
- [JavaScript Projects](https://github.com/javascript-society/javascript-projects): List of projects related with the [JavaScript Path](https://github.com/javascript-society/javascript-path).

### Which programming languages should I use?

My friend, here is the best part of liberty!
You can use **any** language that you want to complete the final project.

The important thing is to **internalize** the core concepts and to be able to use them with whatever tool (programming language) that you wish.

![keep learning](http://i.imgur.com/REQK0VU.jpg)

# How to use this guide

## Order of the classes

This guide was developed to be flexible.
Ideally, it can be consumed in a linear approach, i.e. you complete one course at a time, but in reality different people have different preferences with regard to how many courses they wish to take at once.
Plus, different courses are available at different times and have wildly different time requirements.

Therefore, many students will take the courses in a non-linear order, based on availability and how much time they have to devote to each class.

Any course that is part of 'Core CS' section should be available either regularly, in self-paced format, or in archived form.
Some of the electives are only available once in a while.

## Cost of the classes

No promises are made about the cost of any of the courses.

The web is utterly filled with free educational material if you are willing to spend the time looking for it;
this curriculum has specifically been designed to prioritize *quality* over low cost.
Nevertheless, the reality is that the professors who have made these courses and the platforms who host them are extraordinarily generous.
The content of virtually every course on Coursera and edX is available at no charge, but if you want graded assignments and quizzes, you may have to pay, depending on the course;
yet, these sums of money are nothing compared to the cost of attending their prestigious instutitions.
Coursera is the platform upon which you are most likely to encounter paywalled features, but they offer
[financial aid](https://learner.coursera.help/hc/en-us/articles/209819033-Apply-for-Financial-Aid)
to those eligible.

Some course materials are also available separate from these platforms, such as on YouTube.
Below is a list of courses from the curriculum which have dedicated websites with freely available materials separate from the platforms:
- [Introduction to Computer Science - CS50](https://cs50.harvard.edu/)
- [Linear Algebra: Foundations to Frontiers](http://ulaff.net/)
- [From Nand to Tetris: Building a Modern Computer from First Principles](http://www.nand2tetris.org/)
- [How to Design Programs](http://www.ccs.neu.edu/home/matthias/HtDP2e/)
(Note: This is the **book** upon which *How to Code: Systematic Program Design* is based, but the course is not taught by the book's author; they are completely separate)
- [Mooculus: Calculus One](https://mooculus.osu.edu/)

Just remember that purchasing a course might save you some time and give you some extra motivation, but you cannot buy your way to success in this field.
It's encouraged more as a way to thank the professor for their work.
The most diligent students will be the most successful, regardless of how much or how little they spend.

## How to track and show your progress

1. Create an account in [Trello](https://trello.com/).
1. Copy [this](https://trello.com/b/9DPXYv5f) board to your personal account.
See how to copy a board [here](http://blog.trello.com/you-can-copy-boards-now-finally/).

Now that you have a copy of our official board, you just need to pass the cards to the `Doing` column or `Done` column as you progress in your study.

We also have **labels** to help you have more control through the process.
The meaning of each of these labels is:

- `Main Curriculum`: cards with that label represent courses that are listed in our curriculum.
- `Extra Courses`: cards with that label represent courses that was added by the student.
- `Doing`: cards with that label represent courses the student is current doing.
- `Done`: cards with that label represent courses finished by the student.
Those cards should also have the link for at least one project/article built with the knowledge acquired in such course.
- `Section`: cards with that label represent the section that we have in our curriculum.
Those cards with the `Section` label are only to help the organization of the Done column.
You should put the *Course's cards* below its respective *Section's card*.
- `Extra Sections`: cards with that label represent sections that was added by the student.

The intention of this board is to provide our students a way to track their progress, and also the ability to show their progress through a public page for friends, family, employers, etc.
You can change the status of your board to be **public** or **private**.

### Content Policy

If you plan on showing off some of your coursework publicly, you must share **only** files that you are **allowed** to!
**Do NOT disrespect the code of conduct** that you signed in the beginning of some courses!

## Should I take all courses?

If you are serious about getting an online education comparable to a bachelor's degree in Computer Science, you should absolutely take **all** of the courses under the 'Core CS' section.

These courses are equivalent to about 3/4 of a full bachelor's degree in CS.
So if you want to really complete your studies, then you should select one of the specializations to finish out your program, such as one in Artificial Intelligence or Big Data.

## Duration of the project

If you are able to devote 18-20 hours per week to this curriculum, taking 1-3 clases at a time, you could hypothetically finish the Core CS section in under 2 years.
A specialization would then take you a few more months.

It will probably take longer if you go slower, but regardless, your **reward** will be proportional to your **effort**.

You must focus on your **habit**, and **forget** about goals.
Try to invest 1 ~ 2 hours **every day** studying this curriculum.
If you do this, **inevitably** you'll finish this curriculum.

> See more about "Commit to a process, not a goal" [here](http://jamesclear.com/goals-systems).

## Stay tuned

[Watch](https://help.github.com/articles/watching-repositories/) this repository for futures improvements and general information.

# Prerequisites

This curriculum assumes the student has already taken high school math, including algebra, geometry, and pre-calculus.
Some high school students will have taken calculus, but this is usually only about 3/4 of a college calculus class, so the calculus courses listed above are still recommended.

Apart from those, the only things that you need to know are how to use **Git** and **GitHub**. Here are some resources to learn about them:

**Note**: Just pick one of the resources below to learn the basics. You will learn a lot more once you get started!

- [Try Git](https://try.github.io/levels/1/challenges/1)
- [Ry's Git Tutorial](http://rypress.com/tutorials/git/index)
- [Git - the simple guide](http://rogerdudler.github.io/git-guide/)
- [GitHub Training & Guides](https://www.youtube.com/playlist?list=PLg7s6cbtAD15G8lNyoaYDuKZSKyJrgwB-)
- [GitHub Hello World](https://guides.github.com/activities/hello-world/)
- [Git Immersion](http://gitimmersion.com/index.html)
- [How to Use Git and GitHub](https://www.udacity.com/course/how-to-use-git-and-github--ud775)

# Changelog

**Curriculum Version**: `6.0`

To show respect to all of our students, we will keep a [CHANGELOG](CHANGELOG.md) file that contains all the alterations that our curriculum may suffer.

Now we have a **stable** version of the curriculum, which won't change anymore, only in exceptional cases (outdated courses, broken links, etc).

Our students can trust in this curriculum because it has been **carefully planned** and covers the major **core topics** that a conventional Computer Science program covers.

# How to collaborate

You can [open an issue](https://help.github.com/articles/creating-an-issue/) and give us your suggestions as to how we can improve this guide, or what we can do to improve the learning experience.

You can also [fork this project](https://help.github.com/articles/fork-a-repo/) and send a [pull request](https://help.github.com/articles/using-pull-requests/) to fix any mistakes that you have found.

If you want to suggest a new resource, send a pull request adding such resource to the [extras](https://github.com/open-source-society/computer-science/tree/master/extras) section.

The **extras** section is a place where all of us will be able to submit interesting additional articles, books, courses and specializations, keeping our curriculum *as immutable and concise as possible*.

**Let's do it together! :smile:**

# Community

Subscribe to [/r/opensourcesociety](https://www.reddit.com/r/opensourcesociety/)!

Join us in our [group](https://groups.google.com/forum/#!forum/open-source-society-university)!

You can also interact through [GitHub issues](https://github.com/open-source-society/computer-science/issues).

We also have a chat room! [![Join the chat at https://gitter.im/open-source-society/computer-science](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/open-source-society/computer-science?utm_campaign=pr-badge&utm_content=badge&utm_medium=badge&utm_source=badge)

Add **Open Source Society University** to your [Facebook](https://www.facebook.com/ossuniversity) profile!

> **PS**: A forum is an ideal way to interact with other students as we do not lose important discussions, which usually occur in communication via chat apps.
**Please use our subreddit/group for important discussions**.

# Team

* **Curriculum Founder**: [Eric Douglas](https://github.com/ericdouglas)
* **Curriculum Maintainer**: [Eric Douglas](https://github.com/ericdouglas)
* **Contributors**: [contributors](https://github.com/open-source-society/computer-science/graphs/contributors)

# References

- [Google - Guide for Technical Development](https://www.google.com/about/careers/students/guide-to-technical-development.html)
- [Coursera](https://www.coursera.org/)
- [edX](https://www.edx.org)
- [Udacity](https://www.udacity.com/)
- [Stanford University](https://lagunita.stanford.edu/)
- [MIT Open Courseware](http://ocw.mit.edu/courses/#electrical-engineering-and-computer-science)
- [A DIY Computer Science Education](https://bradfieldcs.com/diy/)
- [Obtaining a Thorough CS Background Online](http://spin.atomicobject.com/2015/05/15/obtaining-thorough-cs-background-online/)