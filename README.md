![Open Source Society University (OSSU)](http://i.imgur.com/GjEbgIJ.png)

<h3 align="center">Open Source Society University</h3>
<p align="center">
  Path to a self-taught education in Computer Science!
</p>
<p align="center">
  <a href="https://github.com/sindresorhus/awesome">
    <img alt="Awesome" src="https://cdn.rawgit.com/sindresorhus/awesome/d7305f38d29fed78fa85652e3a63e154dd8e8829/media/badge.svg">
  </a>
  <a href="https://github.com/open-source-society/computer-science">
	<img alt="Open Source Society University - Computer Science" src="https://img.shields.io/badge/OSSU-computer--science-blue.svg">
  </a>
</p>

# Contents

- [About](#about)
- [Motivation & Preparation](#motivation--preparation)
- [Curriculum](#curriculum)
- [How to use this guide](#how-to-use-this-guide)
- [Prerequisites](#prerequisites)
- [Changelog](#changelog)
- [How to collaborate](#how-to-collaborate)
- [Community](#community)
- [Team](#team)
- [References](#references)

# About

This is a solid path for those of you who want to complete a **Computer Science** curriculum on your own time, at little to no cost, with courses from the best universities in the world.

In our curriculum, we give preference to MOOC (Massive Open Online Course) style courses because these courses were created with our style of learning in mind;
but we include readings where appropriate.
The curriculum then concludes with a final project to show off your skills to your friends and future employers.

# Motivation & Preparation

Here is an interesting link that can make all the difference in your journey.
It's a motivational video that shows a guy that went through the "MIT Challenge", which consists of learning the entire 4-year MIT curriculum for Computer Science in *1 year*.

- [MIT Challenge](https://www.scotthyoung.com/blog/myprojects/mit-challenge-2/)

**Are you ready to get started?**

# Curriculum

- [Intro CS](#intro-cs)
- [Core CS](#core-cs)
  - [Core programming](#core-programming)
  - [Core math](#core-math)
  - [Core systems](#core-systems)
  - [Core theory](#core-theory)
  - [Core applications](#core-applications)
- [Advanced CS](#advanced-cs)
  - [Advanced programming](#advanced-programming)
  - [Advanced math](#advanced-math)
  - [Advanced systems](#advanced-systems)
  - [Advanced theory](#advanced-theory)
  - [Advanced applications](#advanced-applications)
- [Final project](#final-project)
- [Pro CS](#pro-cs)

See also: [Prerequisites](#prerequisites)

---

## Intro CS

Use the first course, CS50, to determine if Computer Science is right for you.
Only proceed in the curriculum if it really excites you.
If it does, use the second and third courses to gain the fundamental skills you need to excel at teaching yourself Computer Science.

**Topics covered**:
imperative programming;
procedural programming;
C;
basic data structures and algorithms;
basic Python;
SQL;
basic HTML, CSS, JavaScript;
learning skills;
cardinality;
and more.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Introduction to Computer Science - CS50](https://www.edx.org/course/introduction-computer-science-harvardx-cs50x#!) | 12 weeks | 10-20 hours/week | none
[Learning How to Learn](https://www.coursera.org/learn/learning-how-to-learn) | 4 weeks | 2 hours/week | none
[Effective Thinking Through Mathematics](https://www.edx.org/course/effective-thinking-through-mathematics-utaustinx-ut-9-01x-0) | 4 weeks | 2 hours/week | none

## Core CS

### Core programming
**Topics covered**: 
basic testing;
functional program composition;
object-oriented program design;
static typing;
dynamic typing;
common design patterns;
ML-family languages (via Standard ML);
Lisp-family languages (via Racket);
Ruby;
and more.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[How to Code: Systematic Program Design (XSeries)](https://www.edx.org/xseries/how-code-systematic-program-design) | 15 weeks | 5 hours/week | none
[Object Oriented Programming in Java](https://www.coursera.org/learn/object-oriented-java) | 6 weeks | 4-6 hours/week | basic programming in C or Java
[Programming Languages, Part A](https://www.coursera.org/learn/programming-languages) | 4 weeks | 8-16 hours/week | recommended: Java, C
[Programming Languages, Part B](https://www.coursera.org/learn/programming-languages-part-b) | 3 weeks | 8-16 hours/week | Programming Languages, Part A
[Programming Languages, Part C](https://www.coursera.org/learn/programming-languages-part-c) | 3 weeks | 8-16 hours/week | Programming Languages, Part B

#### Readings
- **Required** to learn about monads, laziness, purity: [Learn You a Haskell for a Great Good!](http://learnyouahaskell.com/)
- **Required**, to learn about logic programming, backtracking, unification, any resource on Prolog covering these topics, such as:
  - [Prolog Programming for Artificial Intelligence](https://www.amazon.com/Programming-Artificial-Intelligence-International-Computer/dp/0321417461)
  - [Learn Prolog Now](http://www.learnprolognow.org/)
  - [Art of Prolog](https://mitpress.mit.edu/books/art-prolog)

### Core math

**Topics covered**:
mathematical proofs;
number theory;
differential calculus;
integral calculus;
sequences and series;
probability theory;
basic statistics;
O-notation;
graph theory;
linear transformations;
matrices;
vectors;
and more.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Linear Algebra - Foundations to Frontiers](https://www.edx.org/course/linear-algebra-foundations-frontiers-utaustinx-ut-5-04x#!)| 15 weeks | 8 hours/week | high school math
[Calculus One](https://www.coursera.org/learn/calculus1)| 16 weeks | 8-10 hours/week | pre-calculus
[Calculus Two: Sequences and Series](https://www.coursera.org/learn/advanced-calculus)| 7 weeks | 9-10 hours/week | Calculus One
[Mathematics for Computer Science](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-spring-2015/index.htm) | 13 weeks | 5 hours/week | Calculus Two
[Introduction to Probability - The Science of Uncertainty](https://www.edx.org/course/introduction-probability-science-mitx-6-041x-2) | 18 weeks | 12 hours/week | calculus

### Core systems

**Topics covered**:
boolean algebra;
gate logic;
memory;
machine language;
computer architecture;
assembly;
machine language;
virtual machines;
high-level languages;
compilers;
operating systems;
network protocols;
and more.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Build a Modern Computer from First Principles: From Nand to Tetris](https://www.coursera.org/learn/build-a-computer) | 6 weeks | 7-13 hours/week | none
[Build a Modern Computer from First Principles: Nand to Tetris Part II ](https://www.coursera.org/learn/nand2tetris2) | 6 weeks | 12-18 hours/week | Part I
[Introduction to Computer Networking](https://lagunita.stanford.edu/courses/Engineering/Networking-SP/SelfPaced/about)| - | 4â€“12 hours/week | algebra, probability, basic CS

#### Readings
- **Required** since Nand2Tetris does not go deep enough into operating systems: [Operating Systems: Three Easy Pieces](http://pages.cs.wisc.edu/~remzi/OSTEP/)
- Optional: [Computer Networking: A Top-Down Approach](https://www.amazon.com/gp/product/0133594149?pldnSite=1)

### Core theory

Algorithms and data structures is the most important subject you will learn in Core CS, and there are two major course sequences for learning it.
The Princeton Algorithms courses are highly recommended as a more practical, implementation-focused complement to the more theory-focused Stanford Algorithms courses.
Ideally, students would do both sets of courses since they complement each other nicely.
However, Part II of Princeton Algorithms is rarely available, so Stanford Algorithms is the recommended choice if you cannot do both.
Another difference is that Stanford Algorithms assignments can use any programming language;
Princeton Algorithms assignments use Java but don't require extensive Java experience.

**Topics covered**:
divide and conquer;
sorting and searching;
randomized algorithms;
graph search;
shortest paths;
data structures;
greedy algorithms;
minimum spanning trees;
dynamic programming;
NP-completeness;
and more.

#### Stanford Algorithms

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Algorithms (1/4)](https://www.coursera.org/learn/algorithms-divide-conquer) | 4 weeks | 4-8 hours/week | one programming language; proofs; probability
[Algorithms (2/4)](https://www.coursera.org/learn/algorithms-graphs-data-structures) | 4 weeks | 4-8 hours/week | previous algorithms course
[Algorithms (3/4)](https://www.coursera.org/learn/algorithms-greedy) | 4 weeks | 4-8 hours/week | previous algorithms course
[Algorithms (4/4)](https://www.coursera.org/learn/algorithms-npcomplete) | 4 weeks | 4-8 hours/week | previous algorithms course

#### Princeton Algorithms

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Algorithms, Part I](https://www.coursera.org/learn/algorithms-part1) | 6 weeks | 6-12 hours/week | some programming
[Algorithms, Part II](https://www.coursera.org/learn/algorithms-part2) | 6 weeks | 6-12 hours/week | Algorithms, Part I

### Core applications

**Topics covered**:
relational databases;
transaction processing;
data modeling;
neural networks;
supervised learning;
unsupervised learning;
OpenGL;
raytracing;
block ciphers;
authentication;
public key encryption;
and more.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Databases](https://lagunita.stanford.edu/courses/DB/2014/SelfPaced/about)| 12 weeks | 8-12 hours/week | some programming, basic CS
[Machine Learning](https://www.coursera.org/learn/machine-learning)| 11 weeks | 4-6 hours/week | linear algebra
[Computer Graphics](https://www.edx.org/course/computer-graphics-uc-san-diegox-cse167x)| 6 weeks | 12 hours/week | C++ or Java, linear algebra
[Cryptography I](https://www.coursera.org/course/crypto)| 6 weeks | 5-7 hours/week | linear algebra; probability

#### Readings
- Optional: [Transaction Processing: Concepts and Techniques](https://www.amazon.com/Transaction-Processing-Concepts-Techniques-Management/dp/1558601902)
- Optional: [Data and Reality: A Timeless Perspective on Perceiving and Managing Information in Our Imprecise World](https://www.amazon.com/Data-Reality-Perspective-Perceiving-Information/dp/1935504215)
- Optional: [Architecture of a Database System](http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf)

#### Optional courses

Compilers is recommended to any student who took a strong interest in the Programming Languages courses.
Natural Language Processing is recommended to anyone who thinks they want to specialize in machine learning, artificial intelligence, etc.
Cryptography II is recommended to anyone who wants to learn more about zero knowledge systems and other advanced topics in cryptography.
Unfortunately, the latter two courses are rarely available.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Compilers](https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/about)| 9 weeks | 6-8 hours/week | none
[Introduction to Natural Language Processing](https://www.coursera.org/learn/natural-language-processing)| 12 weeks | - | Python programming
[Cryptography II](https://www.coursera.org/course/crypto2)| 6 weeks | 6-8 hours/week | Cryptography I

## Advanced CS

After completing **every single course** in Core CS, students should choose a subset of courses from Advanced CS based on interest.
Not every course from a subcategory needs to be taken.
But students should take *every* course that is relevant to the field they intend to go into.

The Advanced CS study should then end with one of the Specializations under [Advanced applications](#advanced-applications).
A Specialization's Capstone, if taken, may act as the [Final project](#final-project), if permitted by the Honor Code of the course.
If not, or if a student chooses not to take the Capstone, then a separate Final project will need to be done to complete this curriculum.

### Advanced programming

**Topics covered**:
debugging theory and practice;
goal-oriented programming;
GPU programming;
CUDA;
parallel computing;
object-oriented analysis and design;
UML;
large-scale software architecture and design;
and more.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Software Debugging](https://www.udacity.com/course/software-debugging--cs259)| 8 weeks | 6 hours/week | Python, object-oriented programming
[LAFF: Programming for Correctness](https://www.edx.org/course/laff-programming-correctness-utaustinx-ut-p4c-14-01x) | 7 weeks | 6 hours/week | linear algebra
[Introduction to Parallel Programming](https://www.udacity.com/course/intro-to-parallel-programming--cs344) | 12 weeks | - | C, algorithms
[Software Architecture & Design](https://www.udacity.com/course/software-architecture-design--ud821)| 8 weeks | 6 hours/week | Java programming

#### Readings
- Recommended: [Design Patterns](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_1?s=books&ie=UTF8&qid=1488071249&sr=1-1&keywords=Design+Patterns)
- Recommended: [Refactoring](https://www.refactoring.com/)
- Recommended: [The Architecture of Open Source Applications](http://aosabook.org/en/index.html)

### Advanced systems

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Electricity and Magnetism, Part 1](https://www.edx.org/course/electricity-magnetism-part-1-ricex-phys102-1x-0) | 7 weeks | 8-10 hours/week | calculus, basic mechanics
[Electricity and Magnetism, Part 2](https://www.edx.org/course/electricity-magnetism-part-2-ricex-phys102-2x-0) | 7 weeks | 8-10 hours/week | Part 1
[Computation Structures 1: Digital Circuits](https://www.edx.org/course/computation-structures-part-1-digital-mitx-6-004-1x-0) | 10 weeks | 6 hours/week | electricity, magnetism
[Computation Structures 2: Computer Architecture](https://www.edx.org/course/computation-structures-2-computer-mitx-6-004-2x) | 10 weeks | 6 hours/week | previous course
[Computation Structures 3: Computer Organization](https://www.edx.org/course/computation-structures-3-computer-mitx-6-004-3x-0) | 10 weeks | 6 hours/week | previous course
[ops-class.org - Hack the Kernel](https://www.ops-class.org/) | 15 weeks | 6 hours/week | algorithms

**Note 1**:
The Computation Structures courses assume prior knowledge of basic physics, mechanics in particular.
The relevant material will be reviewed in the Rice University 'Electricity and Magnetism' course, but not systematically.
If you are struggling with the Rice courses, you can find a physics MOOC or utilize the materials from Khan Academy:
[Khan Academy - Physics](https://www.khanacademy.org/science/physics)

**Note 2**:
The Computation Structures courses are very, very long, and very hands-on.
A less hands-on alternative is here (note that the rerequisite physics knowledge is still the same):
[Computer Architecture](https://www.coursera.org/learn/comparch)

**Note 3**:
ops-class.org is very, very hands-on.
A completely passive alternative, totally lacking assignments or exams, is here:
[Operating Systems](https://www.youtube.com/view_play_list?p=-XXv-cvA_iBDyz-ba4yDskqMDY6A1w_c)

#### Readings
- Optional: [Modern Operating Systems](https://www.amazon.com/Modern-Operating-Systems-Andrew-Tanenbaum/dp/013359162X)

### Advanced theory

**Topics covered**:
real analysis;
formal languages;
Turing machines;
computability;
computational geometry theory;
propositional logic;
relational logic;
Herbrand logic;
concept lattices;
game trees;
and more.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Introduction to Mathematical Thinking](https://www.coursera.org/learn/mathematical-thinking) | 10 weeks | 10 hours/week | high school math
[Introduction to Logic](https://www.coursera.org/learn/logic-introduction) | 10 weeks | 4-8 hours/week | set theory
[Automata Theory](https://lagunita.stanford.edu/courses/course-v1:ComputerScience+Automata+Fall2016/about) | 8 weeks | 10 hours/week | discrete mathematics, logic, algorithms
[Computational Geometry](https://www.edx.org/course/computational-geometry-tsinghuax-70240183x) | 16 weeks | 8 hours/week | algorithms, C++
[Introduction to Formal Concept Analysis](https://www.coursera.org/learn/formal-concept-analysis) | 6 weeks | 4-6 hours/week | logic, probability
[Game Theory](https://www.coursera.org/learn/game-theory-1) | 8 weeks | x hours/week | mathematical thinking, probability, calculus

### Advanced applications

These Coursera Specializations all end with a Capstone project.
Depending on the course, you may be able to utilize the Capstone as your Final Project for this Computer Science curriculum.
Note that doing a Specialization with the Capstone at the end always costs money.
So if you don't wish to spend money or use the Capstone as your Final, it may be possible to take the courses in the Specialization for free by manually searching for them, but not all allow this.

Courses | Duration | Effort | Prerequisites
:-- | :--: | :--: | :--:
[Robotics (Specialization)](https://www.coursera.org/specializations/robotics) | 26 weeks | 2-5 hours/week | linear algebra, calculus, programming, probability
[Data Mining (Specialization)](https://www.coursera.org/specializations/data-mining) | 30 weeks | 2-5 hours/week | machine learning
[Big Data (Specialization)](https://www.coursera.org/specializations/big-data) | 30 weeks | 3-5 hours/week | none
[Internet of Things (Specialization)](https://www.coursera.org/specializations/internet-of-things) | 30 weeks | 1-5 hours/week | strong programming
[Cloud Computing (Specialization)](https://www.coursera.org/specializations/cloud-computing) | 30 weeks | 2-6 hours/week | C++ programming
[Full Stack Web Development (Specialization)](https://www.coursera.org/specializations/full-stack) | 27 weeeks | 2-6 hours/week | programming, databases
[Data Science (Specialization)](https://www.coursera.org/specializations/jhu-data-science) | 43 weeks | 1-6 hours/week | none

## Final project

OSS University is **project-focused**.
You are encouraged to do the assignments and exams for each course, but what really matters is whether you can *use* your knowledge to solve a real world problem.

After you've gotten through all of Core CS and the parts of Advanced CS relevant to you, you should think about a problem that you can solve using the knowledge you've acquired.
Not only does real project work look great on a resume, the project will *validate* and *consolidate* your knowledge.

Another option is using the Capstone project from taking one of the Specializations in [Advanced applications](#advanced-applications);
whether or not this makes sense depends on the course, the project, and whether or not the course's Honor Code permits you to display your work publicly.
In some cases, it may not be permitted;
do **not** violate your course's Honor Code!

The final projects of all students will be listed in [this](PROJECTS.md) file.
**Submit your project's information in that file after you conclude it**.

Put the OSSU-CS badge in the README of your repository!
[![Open Source Society University - Computer Science](https://img.shields.io/badge/OSSU-computer--science-blue.svg)](https://github.com/open-source-society/computer-science)

- Markdown: `[![Open Source Society University - Computer Science](https://img.shields.io/badge/OSSU-computer--science-blue.svg)](https://github.com/open-source-society/computer-science)`
- HTML: `<a href="https://github.com/open-source-society/computer-science"><img alt="Open Source Society University - Computer Science" src="https://img.shields.io/badge/OSSU-computer--science-blue.svg"></a>`

### Cooperative work

You can create this project alone or with other students!
**We love cooperative work**!
Use our [channels](#community) to communicate with other fellows to combine and create new projects!

### Project Suggestions

- [Projects](https://github.com/karan/Projects): A list of practical projects that anyone can solve in any programming language.
- [app-specs](https://github.com/ericdouglas/app-specs): A curated list of applications specifications and implementations to practice new technologies, improve your portfolio and sharpen your skills.
- [FreeCodeCamp](http://www.freecodecamp.com/): Course that teaches you fullstack JavaScript development through a bunch of projects.
- [JavaScript Projects](https://github.com/javascript-society/javascript-projects): List of projects related with the [JavaScript Path](https://github.com/javascript-society/javascript-path).

### Which programming languages should I use?

My friend, here is the best part of liberty!
You can use **any** language that you want to complete the final project.

The important thing is to **internalize** the core concepts and to be able to use them with whatever tool (programming language) that you wish.
  
## Pro CS

After completing the requirements of the curriculum above, you will have completed the equivalent of a full bachelor's degree in Computer Science, or quite close to one.
You can stop here, but if you really want to make yourself valuable, the next step to completing your studies is to develop skills and knowledge in a specific domain.
Many of these courses are graduate-level.

Choose one or more of the following **specializations**:
- [Mastering Software Development in R Specialization](https://www.coursera.org/specializations/r) by Johns Hopkins University
- [Artificial Intelligence Engineer Nanodegree](https://www.udacity.com/ai) by IBM, Amazon, and Didi
- [Machine Learning Engineer Nanodegree](https://www.udacity.com/course/machine-learning-engineer-nanodegree--nd009) by kaggle
- [Cybersecurity MicroMasters](https://www.edx.org/micromasters/ritx-cybersecurity) by the Rochester Institute of Technology
- [Android Developer Nanodegree](https://www.udacity.com/course/android-developer-nanodegree-by-google--nd801) by Google

These aren't the only specializations you can choose. Check the following websites for **more options**:
- edX: [xSeries](https://www.edx.org/xseries)
- Coursera: [Specializations](https://www.coursera.org/specializations)
- Udacity: [Nanodegree](https://www.udacity.com/nanodegree)

After spending some time in the industry, you should also sharpen your coding and software management skills with the following **readings**:
- Recommended: [Clean Code](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)
- Recommended: [Code Complete](https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670)
- Recommended: [The Pragmatic Programmer](https://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X)
- Recommended: [The Mythical Man-Month](https://www.amazon.com/Mythical-Man-Month-Software-Engineering-Anniversary/dp/0201835959/ref=sr_1_1?s=books&ie=UTF8&qid=1488071430&sr=1-1&keywords=Mythical+Man-Month)

![keep learning](http://i.imgur.com/REQK0VU.jpg)

# How to use this guide

## Order of the classes

This guide was developed to be flexible.
Ideally, Core CS can be consumed in a linear approach, i.e. you complete one course at a time, but in reality different people have different preferences with regard to how many courses they wish to take at once.
Plus, different courses are available at different times and have wildly different time requirements.

Therefore, many students will take the courses in a non-linear order, based on availability and how much time they have to devote to each class.
However, with very few exceptions, everything in Core CS should be completed before you begin Advanced CS.
Pay attention to prerequisites.

## Cost of the classes

No promises are made about the cost of any of the courses.

The web is utterly filled with free educational material if you are willing to spend the time looking for it;
this curriculum has specifically been designed to prioritize *quality* over low cost.
Nevertheless, the reality is that the professors who have made these courses and the platforms who host them are extraordinarily generous.
The content of virtually every course on Coursera and edX is available at no charge, but if you want graded assignments and quizzes, you may have to pay, depending on the course;
yet, these sums of money are nothing compared to the cost of attending their prestigious instutitions.
Coursera is the platform upon which you are most likely to encounter paywalled features, but they offer
[financial aid](https://learner.coursera.help/hc/en-us/articles/209819033-Apply-for-Financial-Aid)
to those eligible.

Some course materials are also available separate from these platforms, such as on YouTube.
Below is a list of courses from the curriculum which have dedicated websites with freely available materials separate from the platforms:
- [Introduction to Computer Science - CS50](https://cs50.harvard.edu/)
- [Linear Algebra: Foundations to Frontiers](http://ulaff.net/)
- [From Nand to Tetris: Building a Modern Computer from First Principles](http://www.nand2tetris.org/)
- [How to Design Programs](http://www.ccs.neu.edu/home/matthias/HtDP2e/)
(Note: This is the **book** upon which *How to Code: Systematic Program Design* is based, but the course is not taught by the book's author; they are completely separate)
- [Mooculus: Calculus One](https://mooculus.osu.edu/)

Just remember that purchasing a course might save you some time and give you some extra motivation, but you cannot buy your way to success in this field.
It's encouraged more as a way to thank the professor for their work.
The most diligent students will be the most successful, regardless of how much or how little they spend.

## How to track and show your progress

1. Create an account in [Trello](https://trello.com/).
1. Copy [this](https://trello.com/b/9DPXYv5f) board to your personal account.
See how to copy a board [here](http://blog.trello.com/you-can-copy-boards-now-finally/).

Now that you have a copy of our official board, you just need to pass the cards to the `Doing` column or `Done` column as you progress in your study.

We also have **labels** to help you have more control through the process.
The meaning of each of these labels is:

- `Main Curriculum`: cards with that label represent courses that are listed in our curriculum.
- `Extra Courses`: cards with that label represent courses that was added by the student.
- `Doing`: cards with that label represent courses the student is current doing.
- `Done`: cards with that label represent courses finished by the student.
Those cards should also have the link for at least one project/article built with the knowledge acquired in such course.
- `Section`: cards with that label represent the section that we have in our curriculum.
Those cards with the `Section` label are only to help the organization of the Done column.
You should put the *Course's cards* below its respective *Section's card*.
- `Extra Sections`: cards with that label represent sections that was added by the student.

The intention of this board is to provide our students a way to track their progress, and also the ability to show their progress through a public page for friends, family, employers, etc.
You can change the status of your board to be *public* or *private*.

### Content Policy

If you plan on showing off some of your coursework publicly, you must share **only** files that you are **allowed** to!
**Do NOT disrespect the code of conduct** that you signed in the beginning of some courses!

## Should I take all courses?

If you are serious about getting an online education comparable to a bachelor's degree in Computer Science, you should absolutely take **all** of the courses under the 'Core CS' section.

These courses are equivalent to about 3/4 of a full bachelor's degree in CS.
So if you want to really complete your studies, then you should select one of the specializations to finish out your program, such as one in Artificial Intelligence or Big Data.

## Duration of the project

If you are able to devote 18-20 hours per week to this curriculum, taking 1-3 clases at a time, you could hypothetically finish the Core CS section in under 2 years.
A specialization would then take you a few more months.

It will probably take longer if you go slower, but regardless, your reward will be proportional to your effort.

You must focus on your habit, and forget about goals.
Try to invest 1 ~ 2 hours every day studying this curriculum.
If you do this, inevitably you'll finish this curriculum.

> See more about "Commit to a process, not a goal" [here](http://jamesclear.com/goals-systems).

## Stay tuned

[Watch](https://help.github.com/articles/watching-repositories/) this repository for futures improvements and general information.

# Prerequisites

This curriculum assumes the student has already taken high school math, including algebra, geometry, and pre-calculus.
Some high school students will have taken calculus, but this is usually only about 3/4 of a college calculus class, so the calculus courses listed above are still recommended.

Apart from those, the only things that you need to know are how to use **Git** and **GitHub**. Here are some resources to learn about them:

**Note**: Just pick one of the resources below to learn the basics. You will learn a lot more once you get started!

- [Try Git](https://try.github.io/levels/1/challenges/1)
- [Ry's Git Tutorial](http://rypress.com/tutorials/git/index)
- [Git - the simple guide](http://rogerdudler.github.io/git-guide/)
- [GitHub Training & Guides](https://www.youtube.com/playlist?list=PLg7s6cbtAD15G8lNyoaYDuKZSKyJrgwB-)
- [GitHub Hello World](https://guides.github.com/activities/hello-world/)
- [Git Immersion](http://gitimmersion.com/index.html)
- [How to Use Git and GitHub](https://www.udacity.com/course/how-to-use-git-and-github--ud775)

# Changelog

**Curriculum Version**: `6.0`

To show respect to all of our students, we will keep a [CHANGELOG](CHANGELOG.md) file that contains all the alterations that our curriculum may suffer.

Now we have a stable version of the curriculum, which won't change anymore, only in exceptional cases (outdated courses, broken links, etc).

Our students can trust in this curriculum because it has been carefully planned and covers the major core topics that a conventional Computer Science program covers.

# How to collaborate

You can [open an issue](https://help.github.com/articles/creating-an-issue/) and give us your suggestions as to how we can improve this guide, or what we can do to improve the learning experience.

You can also [fork this project](https://help.github.com/articles/fork-a-repo/) and send a [pull request](https://help.github.com/articles/using-pull-requests/) to fix any mistakes that you have found.

If you want to suggest a new resource, send a pull request adding such resource to the [extras](https://github.com/open-source-society/computer-science/tree/master/extras) section.

The **extras** section is a place where all of us will be able to submit interesting additional articles, books, courses and specializations, keeping our curriculum *as immutable and concise as possible*.

**Let's do it together! :smile:**

# Community

Subscribe to [/r/opensourcesociety](https://www.reddit.com/r/opensourcesociety/)!

Join us in our [group](https://groups.google.com/forum/#!forum/open-source-society-university)!

You can also interact through [GitHub issues](https://github.com/open-source-society/computer-science/issues).

We also have a chat room! [![Join the chat at https://gitter.im/open-source-society/computer-science](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/open-source-society/computer-science?utm_campaign=pr-badge&utm_content=badge&utm_medium=badge&utm_source=badge)

Add **Open Source Society University** to your [Facebook](https://www.facebook.com/ossuniversity) profile!

> **PS**: A forum is an ideal way to interact with other students as we do not lose important discussions, which usually occur in communication via chat apps.
**Please use our subreddit/group for important discussions**.

# Team

* **Curriculum Founder**: [Eric Douglas](https://github.com/ericdouglas)
* **Curriculum Maintainer**: [Eric Douglas](https://github.com/ericdouglas)
* **Contributors**: [contributors](https://github.com/open-source-society/computer-science/graphs/contributors)

# References

- [Google - Guide for Technical Development](https://www.google.com/about/careers/students/guide-to-technical-development.html)
- [Coursera](https://www.coursera.org/)
- [edX](https://www.edx.org)
- [Udacity](https://www.udacity.com/)
- [Stanford University](https://lagunita.stanford.edu/)
- [MIT Open Courseware](http://ocw.mit.edu/courses/#electrical-engineering-and-computer-science)
- [A DIY Computer Science Education](https://bradfieldcs.com/diy/)
- [Obtaining a Thorough CS Background Online](http://spin.atomicobject.com/2015/05/15/obtaining-thorough-cs-background-online/)
